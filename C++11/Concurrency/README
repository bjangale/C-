// Example Detaching thread to handle other doucment document
void edit_document(std::string const &filename)
{
    open_document_and_display_gui(filename);
    while (!done_editing())
    {
        user_command cmd = get_user_input();
        if (cmd.type == open_new_document)
        {
            std::string const new_name = get_filename_from_user();
            // if the user chooses to open new document you prompt them
            // for document to open start a new thread to open that
            // document and then detach it.
            std::thread t(edit_document, new_name);
            t.detach();
        }
        else
        {
            process_user_input(cmd);
        }
    }
}

######################################################################################################
Mutexes : Mutexes are used to prevent data races by ensuring that only one thread can access critical
          section of code at a time.
1. std::mutex mtx;
    mtx.lock()      - locks the mutex if available.if locked calling thread owns the mutex until it
                      calls unlock()
    mtx.unlock()    - unlocks the mutex. 
    mtx.try_lock()  - try to locks the mutex, return true if locked successfully false otherwise
    mtx.native_handle() - return platform-specific native handle. 

2. std::timed_mutex tmtx;
    tmtx.lock()     - locks the mutex, blocks if the mutex is not available
    tmtx.try_lock() - tries to lock the mutex, returns if the mutex is not available
    tmtx.try_lock_for() - tries to lock the mutex, returns if the mutex has been
                         unavailable for the specified timeout duration
    tmtx.try_lock_until() - tries to lock the mutex, returns if the mutex has been
                            unavailable until specified time point has been reached
    tmtx.unlock()       - unlocks the mutex

3. std::recursive_mutex - allows same thread to lock the mutex multiple times. 

4. std::lock_guard<std::mutex> guard(mtx)
                    - RAII style mechanism for owning a mutex for duration of scoped block.
                      provides convinient way to lock and unlock mutex automatically. 
5. std::lock(MutexTypes&... mtxs) 
                    - function in C++ is used to lock multiple mutexes simultaneously without 
                      causing deadlock. It ensures that all mutexes are locked or none are locked. 
                      If it cannot lock all mutexes, it will unlock any mutexes it has already locked and try again.          
5. std::unique_lock<std::mutex>  
      - unique_lock provides more flexlibility such as differed locking,
        time locking, manual unlocking.
      - if the instance does own the mutex, the destructor must call unlock()
        and if instance does not own the mutext then it must not call unlock()
      - std::unique_lock takes more space and is fraction slow to use than 
        std::lock_gaurd. 

    lock
	locks (i.e., takes ownership of) the associated mutex

    try_lock
	    tries to lock (i.e., takes ownership of) the associated mutex without blocking

    try_lock_for
	    attempts to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns 
	    if the mutex has been unavailable for the specified time duration

    try_lock_until
	    tries to lock (i.e., takes ownership of) the associated TimedLockable mutex, returns if 
	    the mutex has been unavailable until specified time point has been reached

    unlock
	    unlocks (i.e., releases ownership of) the associated mutex

Modifiers:
    swap
	    swaps state with another std::unique_lock
    release
	    disassociates the associated mutex without unlocking (i.e., releasing ownership of) it
    Observers:
    mutex
	    returns a pointer to the associated mutex
    owns_lock
	tests whether the lock owns (i.e., has locked) its associated mutex 
                      
 Locking at appropriate granularity:
    - You may not need the mutex locke across the call to process, so you manually unlock it 
      before the call and then lock it again.  
        void get_and_process_data()
        {
            std::unique_lock<std::mutex> my_lock(the_mutex);
            some_class data_to_process=get_next_data_chunk();
            my_lock.unlock();
            result_type result=process(data_to_process);
            my_lock.lock();
            write_result(data_to_process,result);
        }

    - In general lock should be held for only the minimum possible time needed to perform the 
      required operations. 
    - This also means that time consuming operations such as acquiring another lock or waiting 
      for I/O to complete shouldn't be done while holding the lock unless absolutely neccessary. 
    - Sometimes if you don't hold required locks for the entire duration of an operation, you are
      exposing yourself to race condition. 

6. Protecting share data during initialization
    - Lazy initialization is common in single threaded code each operation that require resource
      first check to see if resource is initialized and then initialize it before use if not. 
        std::shared_ptr<some_resource> resource_ptr;
        void foo()
        {
            if(!resource_ptr)
            {
                resource_ptr.reset(new some_resource);
            }
            resource_ptr->do_something();
        }
    - If the shared resouce itself is safe for concurrent access, the only part that needs to be
      protecting when converting this this to multithreaded code is initialization. 
      Naive translation such as following listing can cause unneccesary serialization of thread 
      using the resource. 

        std::shared_ptr<some_resource> resource_ptr;
        std::mutex resource_mutex;
        void foo()
        {
            std::unique_lock<std::mutex> lk(resource_mutex);
            if(!resource_ptr)
            {
                resource_ptr.reset(new some_resource);
            }
            lk.unlock();
            resource_ptr->do_something();
        }
    - The better way to do this is, inclusing Double-Checked Locking pattern. 
        void undefined_behaviour_with_double_checked_locking()
        {
            if(!resource_ptr)
            {
                std::lock_guard<std::mutex> lk(resource_mutex);
                if(!resource_ptr)
                {
                    resource_ptr.reset(new some_resource);
                }
            }
            resource_ptr->do_something();
        }
      It has potential for nasty race condtion because the read outside the lock is not 
      synchronised with the write done by another thread inside the lock. C++ standard 
      library provides std::once_flag and std::call_once to hand this situation. 
    -std::once_flag
        Rather than locking a mutex and explicitly checking the pointer, every
        thread can just use std::call_once, safe in the knowledge that the pointer will have
        been initialized by some thread (in a properly synchronized fashion) by the time
        std::call_once returns. Use of std::call_once will typically have a lower overhead
        than using a mutex explicitly, especially when the initialization has already been
        done, so should be used in preference where it matches the required functionality.

        std::shared_ptr<some_resource> resource_ptr;
        std::once_flag resource_flag;
        void init_resource()
        {
            resource_ptr.reset(new some_resource);
        }
        void foo()
        {
            std::call_once(resource_flag,init_resource);
            resource_ptr->do_something();
        }